# **学习路线和对应资源**



https://b23.tv/CpTnlIA

​                 ![img](https://docimg8.docs.qq.com/image/JjM-Jc_nk3kaKW-fGnCT0w.png?w=307&h=115)        

[JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化echarts黑马pink老师前端入门基础视频教程(500多集)持续_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Sy4y1C7ha?p=216&spm_id_from=pageDriver)

​                 ![img](https://docimg9.docs.qq.com/image/men4NyKOttvviymwRSeeyQ.png?w=294&h=113)        

https://b23.tv/dYNNood

​                 ![img](https://docimg7.docs.qq.com/image/-1oKeNLxnT9AxyJg7BrjmA.png?w=304&h=115)        

https://b23.tv/f8dBGP7

​                 ![img](https://docimg10.docs.qq.com/image/HFM4dEl3Iwd1TSn98Kcfzg.png?w=299&h=109)        

https://b23.tv/af2i3UL

​                 ![img](https://docimg9.docs.qq.com/image/hkJBVLZODVZ4d0EhruxiLQ.png?w=304&h=112)        

https://b23.tv/i0438It

​                 ![img](https://docimg1.docs.qq.com/image/1-eY60QrA_hpf9B-8ugLBA.png?w=298&h=112)        

https://b23.tv/iKgimMJ

​                 ![img](https://docimg6.docs.qq.com/image/MWUYb1ePNPSpM-70A__W8A.png?w=302&h=112)        

# **JavaScript语法**

## **1. 浏览器执行JS过程**

​                 ![img](https://docimg9.docs.qq.com/image/zZ5MuVavpQ-mw1xwvlAuAg.png?w=722&h=448)        

## **2. JavaScript输入输出语句**

​                 ![img](https://docimg2.docs.qq.com/image/5R0EEr9IahOjoJDzbusjXQ.png?w=691&h=241)        

## **3. 变量的数据类型**

​                 ![img](https://docimg8.docs.qq.com/image/baruRuPbvaOQ6fPqdWSlxA.png?w=690&h=149)        

​                 ![img](https://docimg9.docs.qq.com/image/1Ivo06rtYCH8igI1z1iwFg.png?w=574&h=199)        

​                 ![img](https://docimg4.docs.qq.com/image/q-o1Jh148SRVHvkkL1lkhw.png?w=697&h=208)        

​                 ![img](https://docimg9.docs.qq.com/image/ABSZwgBxofTLe9NVEXB7gQ.png?w=663&h=313)        

​                 ![img](https://docimg6.docs.qq.com/image/7ydQrCpkjPel6c_i3_sqvQ.png?w=668&h=196)        

​                 ![img](https://docimg6.docs.qq.com/image/Z81VTuMhg9cKRU2zqwJErA.png?w=668&h=209)        

​                 ![img](https://docimg4.docs.qq.com/image/LwmpOBg1YyZPzJmjFkLRPg.png?w=478&h=44)        

​                 ![img](https://docimg7.docs.qq.com/image/0XcJt9wfRZLji4oVt9sQVw.png?w=648&h=324)        

## **4. 解释型语言和编译型语言**

​                 ![img](https://docimg10.docs.qq.com/image/L9NK2KlBzZ3x0Dauy-45FA.png?w=619&h=370)                         ![img](https://docimg5.docs.qq.com/image/ChWqq_c8emcTnlylV7bdGg.png?w=495&h=335)        

## **5. 算数运算符**

​                 ![img](https://docimg8.docs.qq.com/image/Kx2G9NQdT_B2_Ik2pNcCLQ.png?w=648&h=177)        

​                 ![img](https://docimg1.docs.qq.com/image/60wO4lsOYLjObLnp_Ua3iA.png?w=664&h=233)        

​                 ![img](https://docimg2.docs.qq.com/image/vbieQlMM8ZXiLcZstYO8yg.png?w=771&h=258)        

​                 ![img](https://docimg10.docs.qq.com/image/O3QioED_gXcpn8-NnHKnOg.png?w=605&h=410)        

​                 ![img](https://docimg8.docs.qq.com/image/L3pqHSVZpx1hn-wVgCBgPg.png?w=741&h=202)        

## **6. 流程控制**



​                 ![img](https://docimg3.docs.qq.com/image/_tBG7m3m6XffXjYRO0hu3g.png?w=677&h=354)        

必须是全等才行，数据类型和数值完全相等才可以。

​                 ![img](https://docimg2.docs.qq.com/image/loNj6xBA2SZB-NVxauzRUQ.png?w=325&h=152)        

## **7. 断点调试**

​                 ![img](https://docimg2.docs.qq.com/image/IaiF3u7CjCgKCIKTLQghrA.png?w=701&h=312)        

1. ## **数组**

索引的长度从0开始

数组的新增有两种办法：

1. 手动修改索引。
2. 修改length长度。arr.length()
3. ​                 ![img](https://docimg5.docs.qq.com/image/-KCEpjI6G9yv3DrjBHthbQ.png?w=783&h=348)        

## **8. 函数**

​                 ![img](https://docimg8.docs.qq.com/image/96bD7ksZJYtI4KwPTlqHnw.png?w=815&h=750)        

​                 ![img](https://docimg2.docs.qq.com/image/1VDzRI8iR0CLepcnE3iLVg.png?w=811&h=428)        

​                 ![img](https://docimg5.docs.qq.com/image/rCCWxWuU0SFZNuGXBOY1ZA.png?w=800&h=207)                         ![img](https://docimg6.docs.qq.com/image/6VZFXnSHutbery32gM-3dA.png?w=832&h=729)        

更细微的差别是，JavaScript 引擎会在 **什么时候** 创建函数。

**函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。**

一旦代码执行到赋值表达式 



```js
let sum = function…
```





的右侧，此时就会开始创建该函数，并且可以从现在开始使用（分配，调用等）。

函数声明则不同。

**在函数声明被定义之前，它就可以被调用。**

例如，一个全局函数声明对整个脚本来说都是可见的，无论它被写在这个脚本的哪个位置。

这是内部算法的原故。当 JavaScript **准备** 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。我们可以将其视为“初始化阶段”。

在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。

**严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。**

​                 ![img](https://docimg2.docs.qq.com/image/lvYtNo7yBOJNSZIhpZw-ZA.png?w=445&h=299)        

函数调用函数的时候，只用调用函数的名字就行

​                 ![img](https://docimg7.docs.qq.com/image/LAKftqacc0CZJFiuwQ_Zeg.png?w=645&h=179)        

写循环、函数先考虑特殊情况，比如这样写：



```js
for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- 没有额外的嵌套
}
```





## **9. 预解析**

Js引擎运行js分为两步 ：预解析  代码执行

\1. 预解析                  ![img](https://docimg2.docs.qq.com/image/2RABsBWcf0H77bqOzAsovw.png?w=1280&h=239.03614457831324)        

## **10. 对象**

​                 ![img](https://docimg3.docs.qq.com/image/3VOnvdFGhE1V6lvjbNmWeg.png?w=624&h=234)        

​                 ![img](https://docimg10.docs.qq.com/image/8k1k71OgQOL5VOZHLmOZsA.png?w=1148&h=118)        

调用属性还有一种方法 obj['age']

​                 ![img](https://docimg1.docs.qq.com/image/i40JdSgaebr3dMkc1HHfFQ.png?w=232&h=173)                         ![img](https://docimg3.docs.qq.com/image/9JY6m6NJ2d4QlSTggV5-xA.png?w=242&h=80)                         ![img](https://docimg6.docs.qq.com/image/KISM6bkSS5t45sZNy6f0dg.png?w=410&h=235)        

利用构造函数创建对象的过程我们页称为对象的实例化

​                 ![img](https://docimg10.docs.qq.com/image/5wApNG-Ps_SI3lKkU_0b0w.png?w=540&h=121)        



对象的键的读取和 键值对的删除

```js
Object.keys(obj)
delete obj[key]
```



## **11. 内置对象**

​                 ![img](https://docimg10.docs.qq.com/image/kLtfH_gU4JuoQnU6K0r5bg.png?w=892&h=107)        

​                 ![img](https://docimg4.docs.qq.com/image/9QcW7ySfj8opESXG0K2uXA.png?w=635&h=181)        

​                 ![img](https://docimg8.docs.qq.com/image/JSJ7hTzyFIRqo0g1BAZs4A.png?w=754&h=21)        

​                 ![img](https://docimg2.docs.qq.com/image/favxq5c_ncjg2raqHwdQPA.png?w=707&h=122)                         ![img](https://docimg1.docs.qq.com/image/t4CHb-Ci_b3Ock56WNw2wQ.png?w=506&h=86)                         ![img](https://docimg8.docs.qq.com/image/nqTz0o3O73HWjxyY0wzwcQ.png?w=369&h=86)        

​                 ![img](https://docimg1.docs.qq.com/image/Ab5gIsyEYvUBEG2WrTzcqw.png?w=749&h=286)        

​                 ![img](https://docimg6.docs.qq.com/image/PXr0tNqFmm6RuFk5D8F-rg.png?w=244&h=81)        返回毫秒数，第三种方法最常用。



​                 ![img](https://docimg1.docs.qq.com/image/WXAIMLTiphlVraY_o4YBqw.png?w=472&h=115)        

​                 ![img](https://docimg5.docs.qq.com/image/eq1TGn7rfJjYo1ckmoLFeA.png?w=788&h=214)        

​                 ![img](https://docimg9.docs.qq.com/image/cZ1UtijG5w8SeqYTltD6mw.png?w=356&h=170)                         ![img](https://docimg9.docs.qq.com/image/ZzYn_CLUSvCCyLrjl4oV9w.png?w=306&h=77)                         

![img](https://docimg2.docs.qq.com/image/ATr_0zRNFhDZ8V32Z124wA.png?w=434&h=211)        



字符串对象

​                 ![img](https://docimg10.docs.qq.com/image/EIid-tNuP6nK5GkcOPiAwA.png?w=298&h=271)         不要大量的拼接字符串，会重新开辟空间

​                 ![img](https://docimg7.docs.qq.com/image/cJROVQ8zVhdCuW7nWxm9-w.png?w=416&h=136)         

这个可以得到所有的a出现的索引

​                 ![img](https://docimg1.docs.qq.com/image/OSwgAm_lEBsZ-JQwO3cIuw.png?w=365&h=180)                         ![img](https://docimg10.docs.qq.com/image/FZJR7uLuOM0PQqZ9nBjySg.png?w=208&h=167)        

这个可以创建key为字符，value为数量的对象					输出

​                 ![img](https://docimg9.docs.qq.com/image/p7xrmLfLVaxx26pIbl0WIA.png?w=794&h=217)        

​                 ![img](https://docimg6.docs.qq.com/image/px6Hp5l1Chjhy_8KxUPmuQ.png?w=220&h=112)                         ![img](https://docimg10.docs.qq.com/image/8YhSnyo_0hwmUbMDxdGINw.png?w=263&h=75)        `                  ![img](https://docimg6.docs.qq.com/image/2z7fYwoVixHQc2JMLC_ASw.png?w=435&h=59)        



## **12. 简单类型和复杂类型**

​                 ![img](https://docimg2.docs.qq.com/image/er4n_miQbO35BSXYoVgd-A.png?w=643&h=106)        

​                 ![img](https://docimg5.docs.qq.com/image/1Q8C35QeiJRs6PjG6tTWcQ.png?w=715&h=101)        

​                 ![img](https://docimg1.docs.qq.com/image/3il0HAdJEtrfQ07mexV15A.png?w=687&h=72)        

​                 ![img](https://docimg1.docs.qq.com/image/iiw-8R-8S2edmKbOtI7Thg.png?w=568&h=395)        



# **Web APIs**

​                 ![img](https://docimg6.docs.qq.com/image/3E-Z8DdR0TiEfDqULml5vA.png?w=593&h=415)        

## **1. API和Web API**

API(Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力而又无需访问源码，或理解内部工作机制的细节。

Web API 是浏览器提供的一套操作浏览器功能和页面元素的API(BOM&DOM)

## **2. DOM 简介**

DOM(Document Object Model)文档对象模型，是一种接口，通过这些接口可以改变网页的内容、结构和样式 

​                 ![img](https://docimg7.docs.qq.com/image/-dEm-bWJIg9oIxGfLV3Y9Q.png?w=742&h=450)        

## **3. 获取元素**

- document.getElmentById() 返回一个匹配id的元素，找到了则返回该Element ，找不到返回Null，只会获取第一个匹配的Id元素，其他的被屏蔽，因为Id是唯一的。而document.getElementsByClassName()可以获取多个匹配class name的元素，返回一个伪数组
- document.getElmentByTagName()返回一个同类标签对象的伪数组集合，操作元素需要遍历

​                 ![img](https://docimg8.docs.qq.com/image/8jVrPqssdzmMuQhkbk2vsQ.png?w=136&h=57)                         ![img](https://docimg10.docs.qq.com/image/TmOkExqXUKFJS1mAESEzcw.png?w=353&h=40)        

​               ![img](https://docimg10.docs.qq.com/image/vy8J07caBu3MprUB1tLrbA.png?w=163&h=131)                         ![img](https://docimg8.docs.qq.com/image/DypOsVvh-sD2H5wSt1sFBw.png?w=361&h=114)                   

![img](https://docimg6.docs.qq.com/image/Q0X3KniXrsMO5hezsLE9qg.png?w=308&h=145)	    			                 

- 当想获取不同元素下的子元素时，可以采用element.getElementsByTagName('标签名')，父元素必须是单个对象，必须指明是哪一个元素对象，获取的时候不包括父元素自己。

​                 ![img](https://docimg5.docs.qq.com/image/30HJ_zZ147qQjNqw5N-9xg.png?w=183&h=132)                         ![img](https://docimg6.docs.qq.com/image/JIfrViXl-nzESiDdmkxHxw.png?w=423&h=76)        

或者采用另外一种方法，就是先给ol标签写上id

​                 ![img](https://docimg2.docs.qq.com/image/2twf0O69tV_SHpSnHn5-1g.png?w=165&h=132)                         ![img](https://docimg5.docs.qq.com/image/g2a_w97z_1ZRHOWyYFv15w.png?w=320&h=67)        

- document.getElementsByClassName(’类名‘)根据类名获得某些元素集合(伪数组)
- doucument.querySelector('选择器') 根据指定选择器返回第一个元素对象，类 .box id #nav
- doucument.querySelectorAll('选择器') 根据指定选择器返回所有的元素对象
- 获取body元素 document.body 获取 html元素 document.documentElement

## **4. 事件基础**

​                 ![img](https://docimg4.docs.qq.com/image/K82goG0bBXXL9t6ONx5BBA.png?w=425&h=169)        

## **5. 操作元素**

​                 ![img](https://docimg8.docs.qq.com/image/WXvs9pScZhrivPVoJQRnQA.png?w=431&h=148)         

- innerText 不识别html标签 而且会 去除空格和换行   innerHTML 识别标签 保留空格和换行
- DOM可以操作如下的表单元素属性：type\value\checked\selected\disabled 

​                 ![img](https://docimg7.docs.qq.com/image/TRxWUlE2Vo7ncMDEa79g1w.png?w=272&h=132)                         ![img](https://docimg7.docs.qq.com/image/wLAID0Si0RZMQsUdJBU4Pw.png?w=381&h=150)        

- 操作属性修改样式属性，JS修改style样式操作，产生的是行内样式，css权重比较高比内嵌样式权重高，所以可以覆盖掉。

​                 ![img](https://docimg9.docs.qq.com/image/05E9vS4v7jTShiQPh0qlFA.png?w=352&h=287)        

- input 表单的得到焦点、失去焦点样式类似于按钮的点击，点击表单表示得到焦点，用onfocus & onblur 表示。

## **6. 通过预定义类修改样式**

- 这样的好处是可以模块化代码而不用每次都写一大堆，需要注意的是会覆盖类名。

![img](https://docimg6.docs.qq.com/image/97kU_4AHSjmrPfPjzdkdMQ.png?w=276&h=245)                       ![img](https://docimg6.docs.qq.com/image/EWGt_HWre6gXj4KKBp-N2Q.png?w=357&h=100)      

## 7. 元素操作总结

<img src="C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325174922548.png" alt="image-20220325174922548">![image-20220325175550368](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325175550368.png)      

- 鼠标经过onmouseover  鼠标离开onmouseout	.

## 8. 自定义属性操作

想要得到元素的属性

- element.属性
- element.getAttribute("属性")  

之前的id="" 是元素的内置属性，用户还可以自定义属性。<font color=red> index = ""</font>

因此可以设置属性值：

- element.属性 = '值'   <font color=red> 主要针对内置属性</font>
- element.setAttribute("属性","值")    <font color=red> 主要针对自定义置属性</font>

![image-20220325193749145](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325193749145.png)

自定义属性的目的是为了保存并使用数据。有些数据可以不保存到数据库中而直接保存在页面中

- ==H5的规范==：设置自定义属性前面加上data-,比如 : data-index = "2"，那么读取的时候可以这样读取
  - div.getAttribute("data-index")
  
  - div.dataset.index \div.dataset['index']
  
- 如果是data-list-name 可以这样读取

  - div.getAttribute("data-list-name")

  - div.dataset.index \div.dataset['listName']

## 9. 节点操作

![image-20220325210146441](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325210146441.png)

![image-20220325210311810](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325210311810.png)

文档节点、元素节点、属性节点、文本节点

<img src="C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325210402823.png" alt="image-20220325210402823" style="zoom:150%;" />

一般节点拥有nodeType nodeName nodeValue三个基本属性，一般我们的操作是元素节点

- 元素节点 nodeType  =1 
- 属性节点 nodeType  =2
- 文本节点 nodeType  =3

```javascript
<div class="demo">
        <div class="box">
            <span class="erweima">×</span>
        </div>
    </div>

    <script>
        // 1. 父节点 parentNode
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
        console.log(erweima.parentNode);
    </script>
```

### 获取父子节点

childnodes  \ parentNode  \ firstChild & lastChild \firstElementChild & lastElementChild() 

<font color=red> firstElementChild & lastElementChild(IE9以上才支持) </font>  

![image-20220325212613619](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325212613619.png)



获取兄弟节点 nextSibling & previousSibling \ nextElementSibling & previousElementSibling 也存在兼容问题，可以自己封装一个

```js
	function getNextElementSibling(element){
        var el = element ;
        while(el = el.nextSibling) {
            if(el.nodeType == 1 ){
                return el;
            }
        }
        return null;
    }
```



### 创建节点

评论区有人评论就会增加元素到页面中

doucument.creatElement('tagName');

然后下一步添加节点

![image-20220325214737598](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325214737598.png)

后面追加元素，类似于数组中的push

![image-20220325214903566](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325214903566.png)

创建节点的一个好方法：

![image-20220401102139264](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220401102139264.png)

### 节点的删除

ul.removeChild(ul.children[0]) ;

![image-20220325220118645](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220325220118645.png)

### 复制节点 

node.clone()

如果括号参数为空或者false，则只复制节点本身，不复制里面的子节点(内容)，true才行

```javascript
<body>
    <ul>
        <li>熊大</li>
        <li>熊一</li>
        <li>熊二</li>
    </ul>
    <script>
        var ul = document.querySelector('ul');
        var lili = ul.children[0].cloneNode();
        ul.appendChild(lili);
    </script>
```

动态插入表格行

```js
<script>
            var datas = [
                {
                    name: 'qqqq',
                    subject: 'js',
                    score: 100,
                },
                {
                    name: 'yyyy',
                    subject: 'jyyyys',
                    score: 100000,
                },
                {
                    name: 'qweqweeqweqw',
                    subject: 'qweqwe',
                    score: 124654500,
                },
            ]

            var tbody = document.querySelector('tbody');
            for (var i = 0; i < datas.length; i++) {
                //创建tr行
                var tr = document.createElement("tr");
                tbody.appendChild(tr);
                // 创建单元格td
                for (var k in datas[i]) {
                    var td = document.createElement('td');
                    tr.appendChild(td)
                    td.innerHTML = datas[i][k];
                }
                var td = document.createElement('td');
                td.innerHTML = '<a href="javascript:;">删除 </a>';
                tr.appendChild(td)
            }

            var as = document.querySelectorAll('a');
            for (var i = 0; i < as.length; i++) {
                as[i].onclick = function () {
                    tbody.removeChild(this.parentNode.parentNode)
                }
            }
        </script>
```

### innerHTML  和 creatElement()区别

```js
		document.body.innerHTML += '<div style="width:100px; height:2px; border:1px solid blue;"></div>';
//拼接字符串耗时太大

        for (var i = 0; i < 1000; i++) {
            var div = document.createElement('div');
            div.style.width = '100px';
            div.style.height = '2px';
            div.style.border = '1px solid red';
            document.body.appendChild(div);
        }
//显然这个时间短

//为了改进innerHTML的效率，可以采用数组Push的方法，然后数组转字符串，因为数组是直接写进内存的，所以速度极快
		var array = [];
        for (var i = 0; i < 1000; i++) {
            array.push('<div style="width:100px; height:2px; border:1px solid blue;"></div>');
        }
        document.body.innerHTML = array.join('');
```





## 10. DOM重点核心

创建：

- doucument.write
- innerHTML
- creatElement

增加

- node.appendChild(child)
- insertBefore(child,node)

删除

- removeChild

改

- 修改元素属性：src \ href\title
- 修改普通内容：innerHTML \innerText
- 修改表单元素： value\type\disabled
- 修改元素样式：style\className

获取、查

- DOM提供的API方法：getElementById \getElementByTagName\
- H5提供的新方法：querySelector\querySelectorAll
- 利用节点操作：parentNode \ children \ previousElementSibling\nextElementSibling

属性操作

- setAttribute \ getAttribute \  removeAttribute

事件操作

- onclick\onmouseover\onmouseout\onfocus\onblur\onmousemove\onmouseup\onmousedown



## 11. 注册事件

<img src="C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328104654281.png" style="zoom: 200%;" />



eventTarget.addEventListener(type,listerner,[,useCapture])

![image-20220328105111475](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328105111475.png)



## 12. 解绑事件

eventTarget.removeEventListener(type,listerner,[,useCapture])

```js
<body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
                alert(11);
                // 1. 传统方式删除事件
                divs[0].onclick = null;
            }
            // 2. removeEventListener 删除事件
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号

        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        // 3. detachEvent
        divs[2].attachEvent('onclick', fn1);

        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
    </script>
</body>
```

看似麻烦，但这样一来的话，提前写好回调函数也可以某种意义上实现模块化，再也不用写匿名函数了，事件一多的匿名函数会写的非常多，这种方式也更灵活，比如事件2发生，就删除函数1，而传统的解绑方式就没这么灵活。

## 13. DOM事件流



<img src="C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328110734725.png" alt="image-20220328110734725" style="zoom:150%;" />



![image-20220328110832565](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328110832565.png)

![image-20220328111351265](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328111351265.png)

![image-20220328111435559](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328111435559.png)

## 14. 事件对象

![image-20220328151536608](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328151536608.png)

```js
 <script>
        // 事件对象
        var div = document.querySelector('div');
        div.onclick = function(e) {
                // console.log(e);
                // console.log(window.event);
                // e = e || window.event; //两种浏览器的方法
                console.log(e);


            }
            // div.addEventListener('click', function(e) {
            //         console.log(e);

        //     })
        // 1. event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看
        // 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数
        // 3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键
        // 4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e
        // 5. 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;
    </script>
```

![image-20220328151758952](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328151758952.png)

常见事件对象的属性和方法

- e.target 返回的是触发事件的对象（元素），this返回的是绑定事件的对象

- e.type 返回事件的类型
- e.preventDefault()阻止默认方式
- e.returnValue

```js
<a href="http://www.baidu.com">百度</a>
    <script>
        var a =  document.querySelector('a');
        a.addEventListener('click',function(e){
            e.preventDefault();
        })
     </script>   
```

## 15. 阻止冒泡

e.stopPropagation()  

e.cancelBubble() = true 

if(e&&e.stopPropagation()){

​	e. stopPropagation()

}

else {

  window.event.cancelBubble = true

}

## 16. 事件委托

事件冒泡本身的特性会带来坏处，也会带来好处！

事件委托的原理：不给每个子节点设置事件监听器，而是事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点。

```js
<body>
    <ul>
        <li>werewrew</li>
        <li>werewrew</li>
        <li>werewrew</li>
        <li>werewrew</li>
        <li>werewrew</li>

    </ul>
    <script>
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function (e) {
            e.target.style.backgroundColor = 'pink'
        })
    </script>

</body>

```

## 17. 常用的鼠标事件

- 禁止鼠标右键菜单：

```javascript
doucument.addEventlistener('contextmenu',funtion(e){
                           e.preventDefault();
                           })
```

- 禁止鼠标选中

```javascript
doucument.addEventlistener('selectstart',funtion(e){                          e.preventDefault();                          })
```

 		e.clientX Y 是可视区的坐标

​		e.pageX Y 是根据文档的相对坐标

​	    e.screenX Y 是根据电脑的相对坐标



- 鼠标点击onclick

- 鼠标经过onmouseover  

- 鼠标离开onmouseout	

- 鼠标按下onmousedown

- 鼠标弹起onmouseup  

- input 表单的得到焦点、失去焦点样式类似于按钮的点击，点击表单表示得到焦点，用onfocus & onblur 表示。

## 18. 常用的键盘事件

- ```js
  document.addEventListener('keyup', function() {
              console.log('我弹起了');
          })
  document.addEventListener('keypress', function() {
                  console.log('我按下了press');
              })
  document.addEventListener('keydown', function() {
                  console.log('我按下了down');
              })
  ```

keydown和keypress在文本框里的特点：事件触发在落入文本框之前	

keyup 事件触发在落入文本框之前	

e.keyCode 返回ASCII码值，但是keyup & keydown 事件不区分大小写，keypress区分



## 19. BOM

Browser Object Model 浏览器对象模型，提供了独立于内容而与浏览器窗口交互的的对象，核心对象是window

![image-20220328201248197](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328201248197.png)

![image-20220328201448057](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328201448057.png)

## 20. window对象的常见事件

### 页面加载事件

```js
window.onload = funciton(){}

window.addEventlistener('load',function(){})
```

![](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328202047924.png)

```js
	window.onload = function() {
            var btn = document.querySelector('button');
            btn.addEventListener('click', function() {
                alert('点击我');
            })
        }
        window.onload = function() {
            alert(22);
        } //只会以这个为准
```

- 但是如果用新的方法就没有限制

```js
window.addEventListener('load', function() {
            var btn = document.querySelector('button');
            btn.addEventListener('click', function() {
                alert('点击我');
            })
        })
        window.addEventListener('load', function() {

            alert(22);
        })
```

- 如果图片、样式表、flash比较多，onload触发可能需要较长的时间，此时用这个方法，而不影响交互结果。

```
document.addEventListener('DOMContentLoaded', function() {
                alert(33);
            })
```

- load 等页面内容全部加载完毕，包含页面的dom元素 图片、flash、css等

- DOMContentLoaded 是DOM 加载完毕，不包含 图片 flash css 就可以执行

### 调整窗口大小事件

```js
 window.addEventListener('resize',function(){}）
```

```js
	<script>
        
        window.addEventListener('load',function(){
            var div = document.querySelector('div')
            window.addEventListener('resize',function(){
                if(window.innerWidth<= 800){
                    div.style.display = 'none';
                }
                else{
                    div.style.display = 'block';
                }

})
        })
    </script>
```

### 定时器

- setTimeout(调用函数，[延迟的毫秒数])
- setInterval(调用函数，[间隔的毫秒数])

```js
funciton calkback(){
	console.log('爆炸了')
}
window.setTimeout(calkback，2000)
```

页面中有很多的定时器，因此有必要自定义

```js
var timer1 = window.setTimeout(calkback，2000)
var timer2 = window.setTimeout(calkback，3000)
```

```js
<body>
    <img src="./Web APIS/自己写的代码/th.jpeg" alt="" class="ad">

    <script>
        var ad = document.querySelector('.ad');

        setTimeout(function(){
            ad.style.display = 'none'
        },5000)
    </script>
    
</body>
```

如果要想中止定时器。则可以利用 clearTimeout(定时器名字);



setInterval(调用函数，[间隔的毫秒数]) 重复调用一个函数。

clearInterval(定时器名字)

```js
<body>
    手机号码：<input type="number" name="" id=""> <button>发送</button>
    <script>
        var ipt = document.querySelector('input');
        var btn = document.querySelector('button');
        var time = 3
        btn.addEventListener('click', function () {
            btn.disabled = true;
            var timer = window.setInterval(function () {
                if (time == 0) {
                    clearInterval(timer);
                    btn.innerHTML = '发送';
                    btn.disabled = false;
                    time = 3
                }
                else {
                    btn.innerHTML = '剩下' + time + '秒';
                    time--;
                }
            }, 1000)
            // btn.disabled = false;
        })
    </script>
```



## 21 . this指向问题

this 指向问题 一般情况下this的最终指向的是那个调用它的对象

![image-20220328212439741](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328212439741.png)

![image-20220328212504334](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328212504334.png)

![image-20220328212514101](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328212514101.png)

## 22. JS执行机制

Js是单线程的，为了解决这个问题，利用CPU的多核能力，H5提出web worker标准，允许JS脚本创建多个线程，于是JS中出现了同步和异步。

- 同步任务都放在主线程执行，形成一个执行栈

- JS的异步是通过回调函数实现的![image-20220328213549954](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328213549954.png)

  

![image-20220328213436148](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328213436148.png)

JS的执行机制

![image-20220328214048923](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328214048923.png)

![image-20220328213659967](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328213659967.png)

![image-20220328213906876](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328213906876.png)

![image-20220328214239056](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328214239056.png)

## 23. location属性

window 对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL，因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。

统一资源定位符(Uniform Resource Locator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

![image-20220328214941280](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328214941280.png)

|    location属性    | 返回值                             |
| :----------------: | ---------------------------------- |
|   location.href    | 获取或设置整个URL                  |
|   location.host    | 返回主机（域名）                   |
|   location.port    | 返回端口号 如果未写返回空字符串    |
| location.pathname  | 返回路径                           |
|  location.search   | 返回参数                           |
|   location.hash    | 返回片段 #后面内容 常见于链接 锚点 |
| location.assign()  | 重定向页面，可以后退               |
| location.replace() | 替换页面，不可以后退               |
| location.reload()  | 重新刷新页面                       |

## 24. navigator属性

![image-20220328222050375](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220328222050375.png)

## 25. history 属性

| history对象方法 | 作用         |
| --------------- | ------------ |
| back()          | 后退         |
| forward()       | 前进         |
| go              | go(1)&go(-1) |

## 26. offset属性

| offset 系列属性      | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetParent | 返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body |
| element.offsetTop    | 返回元素相对带有定位父元素上方的偏移                         |
| element.offsetLeft   | 返回元素相对带有定位父元素左边框的偏移                       |
| element.offsetWidth  | 返回自身包括padding 、边框、内容区的宽度，返回数值不带单位   |
| element.offsetHeight | 返回自身包括padding 、边框、内容区的高度，返回数值不带单位   |

| Offset                              | style                                    |
| ----------------------------------- | ---------------------------------------- |
| offset可以得到任意样式表中的样式值  | style只能得到行内样式表的样式值          |
| offset获得的数值是没有单位的        | style.width获得的是带有单位的字符串      |
| offsetWidth包含padding+border+width | style.width获得不包含Padding和border的值 |
| offsetWidth只可读                   | style.width可读写                        |
|                                     |                                          |

## 27. client属性

| client 系列属性      | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientLeft   | 返回元素左边框的大小                                         |
| element.clientWidth  | 返回自身包括padding 、内容区的宽度，不含边框返回数值不带单位 |
| element.clientHeight | 返回自身包括padding 、内容区的高度，不含边框返回数值不带单位 |
|                      |                                                              |

立即执行函数

(function(){})() \ (function(){}()) 这是匿名函数的写法

也可加上函数名字(function sum(a,b){ return a+b }(a,b)) 

如果放在js文件中，为了避免立即执行函数的多个调用，可以在立即执行函数前面加一个分号

## 28. scroll属性

![image-20220329150835026](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220329150835026.png)

| SCROLL 系列属性      | 作用                                                  |
| -------------------- | ----------------------------------------------------- |
| element.scrollTop    | 返回被卷去的上侧距离，返回数值不带单位                |
| element.scrollLeft   | 返回被卷去的左侧距离，返回数值不带单位                |
| element.scrollWidth  | 返回自身实际宽度，包括padding不含边框返回数值不带单位 |
| element.scrollHeight | 返回自身实际宽度，包括padding不含边框返回数值不带单位 |
|                      |                                                       |

如果是页面被卷去的头部：可以通过window.pageYOffset 

如果是页面被卷去的左侧：可以通过window.pageXOffset 

页面滚动事件 scroll：document.addEventListener('scroll',function(){})

## 29. mouseover 和 mouseenter

mouseover 经过自身盒子会触发，经过子盒子还会触发，

mouseenter只会经过自身盒子触发

之所以这样就是因为Mouseenter不会冒泡

## 30. 动画原理

核心原理：通过定时器setInterval()不断移动盒子位置

1. 获得盒子当前位置
2. 让盒子在当前位置加上1个移动距离
3. 利用定时器不断重复这个操作
4. 加一个结束定时器的条件
5. 注意此元素需要添加定位，才能使用element.style.left

核心代码

```js
function animae(obj, target) {
                obj.timer = setInterval(function () { 
                if(obj.offsetLeft >= target){
                    clearInterval(obj.timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';
            }, 3)
        }
```

为了避免触发事件时，动画的速度会越来越快，可以在进入函数的第一步加入

```js
function animae(obj, target) {
	clearInterVal(obj.timer)
}
```

想要获得缓存动画

```js
obj.style.left = obj.offsetLeft + Math.ceil((target-obj.offsetLeft)/10) + 'px';
```

```js
function animate(obj, target,callback) {
    clearInterval(obj.timer);
    obj.timer = setInterval(function() {
        var step = (target - obj.offsetLeft) / 10;
        step = step > 0 ? Math.ceil(step) : Math.floor(step);
        if (obj.offsetLeft == target) {                  
            clearInterval(obj.timer);
            if(callback){
                callback();
            }
        }
        obj.style.left = obj.offsetLeft + step + 'px';
    }, 15);
}
```

## 31. 移动端触屏事件

- touchstart ：手指触摸到一个DOM元素时触发
- toucumove：手指在一个DOM元素上滑动时触发
- touchend：手指从一个DOM元素上移开时触发

## 32. 触摸事件对象

- e.touches ：返回正在触摸屏幕的所有手指的列表
- e.targetTouches：返回正在触摸当前DOM元素的手指列表（重点）
- e.changedTouches：返回手指状态发生了改变的列表，从无到有从有到无变化

```js
    <script>
        var div = document.querySelector('div');
        var startX = 0;
        var startY = 0;
        var x = 0;
        var y = 0;
        div.addEventListener('touchstart', function (e) {

            startX = e.targetTouches[0].pageX;
            startY = e.targetTouches[0].pageY;
            x = this.offsetLeft;
            y = this.offsetTop;
        })
        div.addEventListener('touchmove', function (e) {

            moveX = e.targetTouches[0].pageX - startX;
            moveY = e.targetTouches[0].pageY -startY;
           this.style.left = x + moveX + 'px';
           this.style.top = y + moveY + 'px';
           e.preventDefault();
        })
    </script>
```

## 33. ClassList

- classList  返回元素的类名

- div.classList.add('类名') 给元素添加类名 

- div.classList.remove('类名') 给元素删除类名 

-  div.classList.toggle('类名') 给元素切换类名 

  

排他思想可以这么实现,就不用for循环了

ol.querySelector(.current).classList.remove('current')

让当前索引号的小li

ol.children[index].classList.add('current')

## 34. fastclick-延时解决方案

![image-20220330155218647](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220330155218647.png)

但是事件比较多的话，每次都要调用这个函数很麻烦，于是有了一中比较好的办法

fastclick地址：http://github.com/ftlabs/fastclick

1. 引入插件
2. 使用

## 35. Swiper插件的使用

地址：https://www.swiper.com.cn/

1. 引入插件
2. 使用

## 36. 本地存储

本地存储特性

1. 数据存储在用户浏览器中
2. 设置、读取方便、甚至页面刷新不丢失数据
3. 容量较大，sessionStorage约5M、localStorage约20M
4. 只能存储字符串，可以将对象编码后存储





window.sessionStorage

1. 生命周期为关闭浏览器窗口
2. 在同一个窗口、页面下数据可以共享
3. 以键值对的形式存储使用

使用方法：

1. sessionStorage.setItem(key,value)
2. sessionStorage.getItem(key,value)
3. sessionStorage.removeItem(key,value)
4. sessionStorage.clear()

window.localStorage

1. 生命周期为永久
2. 在同一个窗口、页面下数据可以共享
3. 以键值对的形式存储使用

使用方法：

1. localStorage.setItem(key,value)
2. localStorage.getItem(key,value)
3. localStorage.removeItem(key,value)
4. localStorage.clear()



# ES6

用面向过程的方法写出来的程序时一份蛋炒饭，而面向对象写出来的程序是一份盖浇饭，面向对象的思维特点：

1. 抽象对象共用的属性和行为封装成一个类（模板）
2. 对类进行实例化，获取类的对象
3. ​                 ![img](https://docimg1.docs.qq.com/image/i40JdSgaebr3dMkc1HHfFQ.png?w=232&h=173)                         ![img](https://docimg3.docs.qq.com/image/9JY6m6NJ2d4QlSTggV5-xA.png?w=242&h=80)                         ![img](https://docimg6.docs.qq.com/image/KISM6bkSS5t45sZNy6f0dg.png?w=410&h=235)      

## 1. 创建类

```js
class Star {
	constructor(uname){
        this.uname = uname;
    }
	sing(song){
        console.log(this.uname + song )
    }
}
 var ldh  = new Star('刘德华');
```

constructor() 在 new时，就会自动调用这个函数

共用的方法不需要this，不需要function

## 2. 继承

用extends 关键字进行继承父类的属性和方法

class Son extends Father {}

```js
   <script>
        class Father {
            constructor(x,y){
                this.x = x 
                this.y = y

            }           
            sum(){
                console.log(this.x+this.y);
            }
        }

        class Son extends Father {
            constructor(x,y){
                //this.x = x;
                //this.y = y;
                super(x,y)//调用了父类的构造函数
            }

        }
        var son = new Son(1,2);
        son.sum();
```



子类为什么用不了父类的方法？是因为子类方法中的参数传递给了子类创建的实例，，而sum函数指向的是父类中创建的实例，而super(x,y)则调用了父类的构造函数

```js
<script>
        class Father {
            say() {
                console.log('爸爸');
            }
        }
        class Son {
            say() {
                console.log('儿子');
            }
        }
        son = new Son();
        son.say();//儿子
    </script>
```

继承中如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的，如果没有就去查找父类中有没有，如果有就执行父类的这个方法（就近原则）。如果想要同时调用子类和父类就需要用super

```js
<script>
        class Father {
            say(){
                return '爸爸'
            }
        }
        class Son  extends Father{
            
            say(){
                console.log(super.say()+'的儿子');
            }
        }
            
        son = new Son();
        son.say()
    </script>
```

super.say()就是调用父类中的普通函数say()

- ！！！！super必须放在子类this之前

- 构造器的this指向实例对象，方法里面的this指向方法的调用者

创建节点的一个好方法：this.**insertAdjacentHTML**()

![image-20220401102139264](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220401102139264.png)

## 3. 构造函数与原型对象prototype

ES6 --> ECMAscript6.0

![img](https://docimg6.docs.qq.com/image/KISM6bkSS5t45sZNy6f0dg.png?w=410&h=235)

- 实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员，只能通过实例化的对象来访问，不可以通过构造函数来访问

- 静态成员，在构造函数上本身添加的成员， Star.sex = '男', sex就是静态成员，静态成员只能通过构造函数来访问，不能通过对象来访问



构造函数很好用，但是！！存在浪费内存的问题，每次new实例化对象的时候，都会开辟一个新的空间用来装sing这个function(){}

```js
ldh.sing === zxy.sing  //false 地址是不一样的
```

JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，这个prototype就是一个对象，原型对象可以认为是所有实例化对象的祖先（父类、原型），这个对象所有的属性和方法，都会被构造函数所拥有。所以一般情况下，公共属性定义到构造函数里面，公共的方法定义到原型对象身上。

```js
Star.prototype.sing = function(){}
ldh.sing === zxy.sing  //true 地址是一样的，都是原型对象中的方法。
```

## 4. 对象原型_ _proto_ _ 

为什么可以使用原型对象中的方法呢？因为构造函数实例化的对象中一定有一个属性‘ _ _proto_ _ ：Object’ 这个属性的指向是构造函数的原型对象prototype，Object==prototype

```js
ldh.__proto__ === Star.prototype //true
```

原型对象可以认为是所有实例化对象的祖先（父类、原型），首先看ldh对象身上是否有sing方法，如果有就执行这个ldh对象上的sing,如果没有sing这个方法，因为有‘ _ _proto_ _ ：Object’的存在，就去构造函数的原型对象prototype身上去查找sing这个方法。

![image-20220401220531438](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220401220531438.png)

‘ _ *proto* _ ：Object’对象原型的意义就在于为对象的查找机制提供一个方向或者说一条路线，但是它是一个非便准属性，因此实际开发中，不可以使用这个属性，它只是指向原型对象prototype

## 5. 原型的contructor函数

```js
console.log(Star.prototype) 
//{sing: ƒ, constructor: ƒ}
console.log(ldh.__proto__);
//{sing: ƒ, constructor: ƒ}
console.log(ldh);
//Star {uname: '刘德华', age: 18, bbb: {…}}
console.dir(ldh);
//Star
```

原型对象里含有构造函数，用来记录对象引用于哪个构造函数



```js
//如果想省事这样写
Star.prototype = {
            sing: function() {
                console.log('我会唱歌');
            },
            movie: function() {
                console.log('我会演电影');
            }
        }

//跟以下就不等价了啊！！@#！@#！@#
Star.prototype.sing = function() {
            console.log('我会唱歌');
        };
        Star.prototype.movie = function() {
            console.log('我会演电影');
        }
```

本来的原型对象含有的是这些

![image-20220402163921348](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220402163921348.png)

一旦我们修改了原来的原型对象,给原型对象赋值的是一个对象,会覆盖掉，则必须手动的利用constructor指回原来的构造函数，

```js
Star.prototype = {
            constructor: Star,
            sing: function() {
                console.log('我会唱歌');
            },
            movie: function() {
                console.log('我会演电影');
            }
        }
```

![image-20220402164454705](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220402164454705.png)

![image-20220402164841215](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220402164841215.png)

构造函数和原型对象中的this都指向实例对象。

- 如果要实现父类中的方法继承，则不可以使用！！！！

```js
Son.prototype = Father.prototype
```

因为这样改变将Father.prototype的地址给了Son.prototype ，再对Son.prototype 进行其他方法的创建和修改时也会改变Father.prototype中的方法，示意图如下

![image-20220403135134716](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220403135134716.png)

我们可以使用原型链的方法

```js
//new Father()创建了一个Father的实例对象，实例对象__proto__可以指向Father 的原型对象Father.prototype，因此 Son.prototype 可以使用Father.prototype中的方法。
Son.prototype = new Father();
// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
Son.prototype.constructor = Son;
```

![image-20220403135603671](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220403135603671.png)

## 6. 利用原型对象扩展内置对象方法



```js
Array.prototype.sum = function(){
            var sum = 0;
            for (var i = 0 ;i < this.length; i ++){
                sum += this[i];
            }
            return sum ;
        }
        var arr = [1,2,3];
        console.log(arr.sum());
```

## 7. 改变this指向

- call()

1. 可以调用函数

   ```js
   function fn(){
               console.log(this);
           }
           fn.call()
   //此处返回的是window
   ```

2. 可以改变函数的this指向

   ```js
   function fn(key){
               console.log(this[key]);
           }
           o  = {
               age : 18 ,
               name :'andy'
           }
           fn.call(o,'age') // 18
           fn.call(o,'name') // andy
   
   ```

3. ES6 之前没有提供extends 继承，但是！#！@#

    我们通过调用改变的父类构造函数时的调用指向实现属性继承！@#！~

```js
function Father(uname, age) {
            this.uname = uname;
            this.age = age;
        }
function Son(uname, age,score) {
            Father.call(this,uname,age,score)
            this.score = score ;
        }
        ldh = new Son('刘德华',18,99)
```

- apply() 

  传递参数要用数组的形式

  ```js
  var o = {
               name : 'qiao guo peng ',
           }
           function fn(arr,arr1) {
              console.log(this);
              console.log(arr);
              console.log(arr1);
           }
           fn.apply(o,[11,23])
           );
  ```

  可以重写内置对象的方法

  ```js
  var arr = [1,2,5,7,9,3]     console.log(Math.max.apply(null,arr)                                   console.log(Math.min.apply(null,arr
  ```

- bind()  不会调用原来的函数，可以改变this指向，返回的是原函数改变this之后产生的新函数，如果有的函数我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用bind

  ```js
  <button>按我</button>
      <script>
          var btn = document.querySelector('button');
          btn.addEventListener('click',function(){
              this.disabled = true ;
              setTimeout(function(){
                  this.disabled = false; 
              }.bind(this),2000)
          })
  ```

  ![image-20220405095438470](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220405095438470.png)

## 8. 类的本质

```js
class Star {

        }
console.log(typeof Star); //function
        // ES6 之前通过 构造函数+ 原型实现面向对象 编程
        // (1) 构造函数有原型对象prototype 
        // (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身
        // (3) 构造函数可以通过原型对象添加方法
        // (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象


        // (1) 类有原型对象prototype 
        console.log(Star.prototype);
        // (2) 类原型对象prototype 里面有constructor 指向类本身
        console.log(Star.prototype.constructor);
        // (3)类可以通过原型对象添加方法
        Star.prototype.sing = function() {
            console.log('冰雨');
        }
        var ldh = new Star();
        console.dir(ldh);
        // (4) 类创建的实例对象有__proto__ 原型指向 类的原型对象
        console.log(ldh.__proto__ === Star.prototype);
```

## 9. 数组新增方法

- forEach  对每个元素执行相应的操作

  ```js
  var arr = [1,2,3]
  arr.forEach(function(value,index,array){
  	console.log(value,index)
  })
  //1 0
  //2 1
  //3 2
  ```

- filter	对每个元素进行过滤

```js
var arr = [1, 2, 3]
newarr = arr.filter(function (value, index) {
         return value > 1
})
console.log(newarr);//[2,3]
```

- some  返回数组中的元素是否满足指定条件，返回的是布尔值,一旦遇到true就终止遍历

```js
var arr = [1, 2, 3]
        arr_ = arr.some(function (value) {
            return value >= 20;
        })
        console.log(arr_); //false
        var arr = ['pink', 'blue', 'red']
        arr1_ = arr.some(function (value) {
            return value == 'pink';
        })
        console.log(arr1_);//true
```

## 10. trim()

str.trim()返回两侧的空格



## 11. Object.defineProperty 

Object.defineProperty(obj,prop,description)

![](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220404160509264.png)

enumerable不可以被枚举

```js
Object.defineProperty(obj, 'adress', {
            value: '中国山东找蓝翔',
            enumerable :false,
        })
        console.log(Object.keys(obj)); 
       //['id', 'pname', 'price']
        console.log(obj);
//{id: 1, pname: '小米', price: 199.99, adress: '中国山东找蓝翔'}
```

```js
Object.defineProperty(obj, 'adress', {
            configurable:false
        })
Object.defineProperty(obj, 'adress', {
    		value: '中国山东',
            configurable:true
        })
//报错，因为不允许修改特性了了 Cannot redefine property: adress
```

对象的键的读取和 键值对的删除

```js
Object.keys(obj)
delete obj[key]
```

## 12. 函数进阶

1. function fun(){}
2. var fun = function(){}![image-20220404161327894](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220404161327894.png)

![image-20220404161410091](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220404161410091.png)

函数的种类

```js
// 1. 普通函数
        function fn() {
            console.log('人生的巅峰');
        }
        // fn();   fn.call()
        // 2. 对象的方法
        var o = {
            sayHi: function() {
                console.log('人生的巅峰');
            }
        }
        o.sayHi();
        // 3. 构造函数
        function Star() {};
        new Star();
        // 4. 绑定事件函数
         btn.onclick = function() {};   // 点击了按钮就可以调用这个函数
        // 5. 定时器函数
         setInterval(function() {}, 1000);
//  这个函数是定时器自动1秒钟调用一次
        // 6. 立即执行函数
        (function() {
            console.log('人生的巅峰');
        })();
        // 立即执行函数是自动调用
```

![image-20220404170310204](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220404170310204.png)



## 13. 严格模式

可以在整个script脚本内声明（整体），也可以在函数的前面声明（部分）

1. 变量名必须先声明再使用
2. 不能随意删除已经声明好的变量
3. 严格模式下全局作用域中的函数this指向的是undefined
4. 定时器函数this指向还是window
5. 函数不能有重叠的参数
6. 不允许在非函数代码块中再写函数

## 14. 高阶函数

接受函数作为参数或者将函数作为返回值输出 

## 15. 闭包

1. 函数内部可以访问全局变量
2. 函数外部不可以访问局部变量
3. 当函数执行完毕，本作用域内的局部变量会销毁

闭包（closure）指有权访问另一个函数作用域中变量的函数，被使用变量所在函数是闭包函数 f(n)

```js
function fn() {
            var num = 10;

            function fun() {
                console.log(num);
            }
            fun();
        }
        fn();
```

通过闭包可以使得函数外部作用域访问函数内部的局部变量

```js
function fn() {
            var num = 10;
            function fun() {
                console.log(num);
            }
            return fun();
    //return function(){}
        }
       var f =  fn();
		f();
```

闭包的主要作用：延申了变量的作用范围

```js
var car = (function() {
            var start = 13; // 起步价  局部变量
            var total = 0; // 总价  局部变量
            return {
                // 正常的总价
                price: function(n) {
                    if (n <= 3) {
                        total = start; //使用了匿名函数内的局部变量，此匿名函数就是一个闭包
                    } else {
                        total = start + (n - 3) * 5 //使用了匿名函数内的局部变量
                    }
                    return total;
                },
                // 拥堵之后的费用
                yd: function(flag) {
                    return flag ? total + 10 : total;
                }
            }
        })();
```

## 16. 递归

```js
function getID(json, id) {
            var o = {};
            json.forEach(function(item) {
                // console.log(item); // 2个数组元素
                if (item.id == id) {
                    // console.log(item);
                    o = item;
                    // 2. 我们想要得里层的数据 11 12 可以利用递归函数
                    // 里面应该有goods这个数组并且数组的长度不为 0 
                } else if (item.goods && item.goods.length > 0) {
                    o = getID(item.goods, id);
                }

            });
            return o;
        }
```

## 17. 拷贝

1. 浅拷贝

   

   ```js
   for (var k in obj) {
               // k 是属性名   obj[k] 属性值
               o[k] = obj[k];
           }
   ```

   ```
    Object.assign(o,obj)
   ```

   

2. 深拷贝

![image-20220408142844356](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220408142844356.png)

```js
function deepcopy(newobj, oldobj) {
            for (var k in oldobj) {
                var item = oldobj[k];
                if (item instanceof Array) {
                    newobj[k] = [];
                    deepcopy(newobj[k], item)

                }
                else if (item instanceof Object) {
                    newobj[k] = {};
                    deepcopy(newobj[k], item)
                }
                else {
                    newobj[k] =item;
                }
            }
        }
```

## 18. 正则表达式

![image-20220409110028752](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220409110028752.png)

创建正则表达式

```js
// 1.利用RegExp对象创建
        var regexp = new RegExp(/123/)
// 2.利用字面量创建
        var regexp = /123/
//测试正则表达式
        console.log(regexp.test(123));     
```

边界符

- ^表示以字符串开头
- $表示以选定字符串结尾

字符类

- /abc/表示只要包含abc就返回true
- /^abc$/表示只能是abc
- /[abc]/表示只要包含a,b,c一个就返回true，三选一
- /^[abc]$/表示只能是a,b,c中的一个
- /^[a-zA-z0-9]$/表示只能是a-zA-Z0-9中的一个
- /^[ ^a-zA-z0-9]$/表示不能是a-zA-Z0-9中的一个

量词符

- /^a*$/表示 *可以出现0到很多次
- /^a+$/表示 +可以出现1到很多次
- /^a?$/表示 ?只能出现0到1次
- /^a{3}$/表示 {3}只能出现3次
- /^a{3,}$/表示 {3,}可以大于出现3次
- /^a{3,16}$/表示 {3,16}可以大于出现3次小于16次

小括号 表示优先级

```js
var reg = /^abc{3}$/; // 它只是让c重复三次   abccc
var reg = /^(abc){3}$/; // 它是让abcc重复三次
```

预定义类

- \d = [0-9]
- \D = [ ^ 0-9]
- \w = [A-Za-z0-9_]
- \W =  [ ^A-Za-z0-9_]
- \s = [\t\r\n\v\f] 匹配空格，包括换行符，制表符，空格符
- \S = [ ^\t\r\n\v\f] 

座机的格式：010-12345678 或者0530-1234567

```js
var reg = /^\d{3}-\d{8}|\d{4}-\d{7}$/
```

正则表达式参数

- /reg/g  : 全局匹配
- /reg/i   : 忽略大小写
- /reg/gi : 全局匹配+忽略大小写

## 19. let 、const、变量的解构赋值 

ES的全称是ECMAScript，它是由ECMA国际标准化组织通过ECMA-262标准化的一项脚本语言。个人或机构向组织提交新功能，每年的6月都会发布一次新版本，ES6指的是ES2015及后续的版本。标准的诞生意味着语言的完善，功能的加强。

1. let声明的变量只在所处于的块级有效(var会改变每个for中的i的值，因为是全局的，而let不会，所以最后var会越界)
2. 允许批量声明并赋值，不允许重复声明
3. 不存在变量提升：就是在变量创建之前使用（比如输出：输出的是默认值），let不存在，var存在但是为undefined；
4. 不影响作用域链!![image-20220411112301651](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220411112301651.png)

--------------------------------------------------------------------------------------

1. 声明必须赋初始值； 

2. 不允许重复声明；  

3. 值不允许修改；

4. 块儿级作用域（局部变量）；

5. 对数组和对象的元素修改，不算对常量的修改，不会报错，

   ```js
   const tem = ['uzi','mlxg'];
   tem.push  = ('meiko')
   ```

   所以一般声明对象类型使用 const，非对象类型声明选择 let；

-----------------------------

![image-20220411120357482](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220411120357482.png)

![image-20220411120410620](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220411120410620.png)

## 20. 模板字符串

模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：

- 字符串中可以出现换行符； ’‘  ”“不行的
- 可以使用 ${xxx} 形式引用变量；

## 21. 简化对象

ES6允许在对象的大括号内直接写入变量和函数作为对象的属性和方法

![image-20220411154909992](C:\Users\乔国鹏\AppData\Roaming\Typora\typora-user-images\image-20220411154909992.png)

## 22. 箭头函数
